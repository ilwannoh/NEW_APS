# 생산계획 스케줄러 구현 가이드

## 요구사항

다음과 같은 테트리스 스타일의 생산 계획 스케줄러를 React로 구현해주세요:

### 1. 시간 구조
- **4개 구간으로 단순화**: "1구간", "2구간", "3구간", "4구간" 
- 각 구간은 동일한 크기의 그리드 셀로 표현
- 절대적인 시간 표시 없이 상대적 구간으로만 표현

### 2. 그리드 시스템
```
설비명     | 1구간 | 2구간 | 3구간 | 4구간 |
---------|-------|-------|-------|-------|
칭량기1   |  [블록]  |   빈칸  |  [블록]  |   빈칸  |
혼합기1   |   빈칸  |  [블록]  |   빈칸  |  [블록]  |
타정기1   |   빈칸  |   빈칸  |  [블록블록] |   빈칸  |
```

### 3. 핵심 규칙

#### A. 그리드 경계 준수
- 모든 작업 블록은 반드시 그리드 경계에 맞춰 배치
- 블록이 여러 구간을 차지하는 경우, 연속된 구간에만 배치 가능
- 구간 중간에서 시작하거나 끝나는 것 금지

#### B. 빈 공간 표현
- 작업이 할당되지 않은 구간은 빈 셀로 표시
- 빈 셀도 명확한 경계선으로 구분
- 드래그 앤 드롭 시 빈 셀에만 배치 가능

#### C. 공정 연결 (테트리스 규칙)
- 동일 배치: 칭량기1 → 혼합기1 → 타정기1 순서
- 이전 공정이 끝나는 구간의 다음 구간에 다음 공정 시작
- 예: 칭량기1이 1구간에서 끝나면, 혼합기1은 2구간에서 시작

### 4. 데이터 구조 예시

```javascript
const scheduleData = [
  {
    equipment: "칭량기1",
    tasks: [
      { 
        id: 1, 
        batch: "125",  // 엑셀 C컬럼의 실제 배치번호
        product: "기넥신에프정", 
        startSlot: 0,  // 1구간
        duration: 1,   // 1구간 동안
        color: "#3B82F6" 
      },
      { 
        id: 2, 
        batch: "225",  // 다음 배치번호
        product: "페브릭정", 
        startSlot: 2,  // 3구간
        duration: 1, 
        color: "#EF4444" 
      }
    ]
  },
  {
    equipment: "혼합기1", 
    tasks: [
      { 
        id: 3, 
        batch: "125",  // 동일 배치 (칭량기1과 연결)
        product: "기넥신에프정", 
        startSlot: 1,  // 2구간 (칭량기1 다음)
        duration: 1, 
        color: "#3B82F6" 
      },
      { 
        id: 4, 
        batch: "225",  // 동일 배치 (칭량기1과 연결)
        product: "페브릭정", 
        startSlot: 3,  // 4구간 (칭량기1 다음)
        duration: 1, 
        color: "#EF4444" 
      }
    ]
  }
];
```

### 8. 배치번호 규칙 (엑셀 파일 기준)
- **형식**: 3자리 숫자 (예: 125, 225, 325, 425)
- **패턴**: 100씩 증가 (125 → 225 → 325 → 425)
- **데이터 소스**: sales_plan_mixed_products.xlsx의 Sheet1, C컬럼에서 참조
- **동일배치**: 같은 배치번호는 모든 공정(칭량기→혼합기→타정기)에서 동일하게 사용

### 9. 엑셀 데이터 연동 방법
```javascript
// 엑셀 파일에서 배치번호 읽기
import * as XLSX from 'xlsx';

const loadBatchNumbers = async () => {
  const response = await fetch('sales_plan_mixed_products.xlsx');
  const arrayBuffer = await response.arrayBuffer();
  const workbook = XLSX.read(arrayBuffer);
  const sheet = workbook.Sheets['Sheet1'];
  
  // C컬럼에서 배치번호 추출 (헤더 제외)
  const range = XLSX.utils.decode_range(sheet['!ref']);
  const batchNumbers = [];
  
  for (let row = 1; row <= range.e.r; row++) { // row 1부터 시작 (헤더 제외)
    const cellAddress = XLSX.utils.encode_cell({ c: 2, r: row });
    const cell = sheet[cellAddress];
    if (cell && typeof cell.v === 'number') {
      batchNumbers.push(cell.v);
    }
  }
  
  return batchNumbers; // [125, 225, 325, 425, ...]
};
```

### 5. UI 요구사항

#### A. 레고/테트리스 블록 스타일
- 각 작업을 3D 느낌의 블록으로 표현
- 상단에 원형 돌기 (레고 스타일)
- 그라데이션으로 입체감 표현
- 배치 번호와 제품명 표시

#### B. 드래그 앤 드롭
- 블록을 드래그하여 다른 구간으로 이동 가능
- 이동 시 테트리스 규칙 검증 (연결성 확인)
- 규칙에 맞지 않으면 원래 위치로 복귀

#### C. 연결선 표시
- 동일 배치의 공정 간 화살표로 연결
- SVG로 곡선 화살표 구현
- 배치별 색상으로 구분

### 6. 중요한 구현 포인트

1. **그리드 기반 배치**: CSS Grid나 Flexbox로 정확한 4열 그리드 구현
2. **빈 셀 처리**: 각 설비-구간 조합마다 명시적으로 빈 셀 렌더링
3. **드롭 영역**: 각 빈 셀을 드롭 가능 영역으로 설정
4. **연결 검증**: 드롭 시 이전/다음 공정과의 연결성 실시간 검증

### 7. 스타일링 가이드

- 설비명: 좌측 고정, 진한 파란색 배경
- 그리드 셀: 흰색 배경, 회색 테두리
- 작업 블록: 제품별 색상, 둥근 모서리, 그림자
- 빈 셀: 밝은 회색, 점선 테두리 (드래그 오버 시 하이라이트)

이렇게 구현하면 정확한 그리드 기반의 스케줄러가 완성될 것입니다!